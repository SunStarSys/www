Title: What Is <em>Smart Content Dependency Management&trade;</em> All About?
Dependencies: *.md.en
Categories: CMS, Architecture

[TOC]

## Abstract

*Smart Content Dependency Management&trade;* is about the circle of ideas related to providing support and facilitation for *incremental builds*, while staying true to the **Content Normalization Principle** &mdash; that *permalinks* should be the single source of truth, no matter how their content is curated throughout the source tree and resulting build artifacts.

## Caveats

This only ever matters when you need to weigh the expense of performing full site builds every time you need to tweak the content on a webpage. If your website has less than 1000 html files in it, **relax**, and read the following with an eye towards your future needs. You chose to use our platform, that's designed to scale with you, not against you.

By default, our build system will build only the files you changed, without concern for the intra-file dependencies (unless you specify them in `%path::dependencies` &mdash; more on that below). If the file you changed is in the `templates/` or `lib/` directory, as well as whenever you delete content, a full site build will trigger instead.

## Weaving Your Website's *Content Topology* Together

Mathematically, a *Topology* `$$\tau$$` is a complete specification of the *open* subsets of a space `$$X$$`, the purpose of which is to indicate the proximity relationships between *points* `$$x$$` of the space `$$X$$`.  When `$$X$$` is a graph, a *topology* `$$\tau$$` for `$$X$$` amounts to specifying the edges connecting the vertices of the graph together (here vertices are viewed as the *points* of `$$X$$`, and the connecting edges determine the neighborhoods of those points as *basis open sets* for the topoology).  A *directed graph topology* is essentially the same thing, but incorporates a reference to a topological embedding of `$$(X,\tau)$$` into a larger topological space `$$(Y,\sigma)$$` , where the embedding's edge connections are represented by directional, non-intersecting (Jordan) curves.

The latter concept is what we will utilize when discussing the *content topology* `$$\tau$$` associated to the space `$$X$$` of source files beneath your site's `content/` subdirectory (here `$$(Y,\sigma)$$` is `$$\mathbb{R}^n$$` with its metric topology for `$$n \in \{2,3\}$$`, and the edges of `$$X$$` are non-intersecting, directed Jordan curves connecting a file `$$x \in X$$` to its set of files upon which `$$x$$` depends: `$$\{x' \in X | x \rightarrow x' \}$$`).

Having <!-- #teaser -->a clear understanding of your website's *content topology* will ensure you can maximize the performance of our build technology at scale <!-- #teaser -->. We take the information you provide to `%path::dependencies` during the build's load of your website's `lib/path.pm` file, construct a reverse map of dependent files, and use *that reverse map* to determine the full corpus of files to build for any given `svn commit` you make to our system.

It's important to note that the dependency relationships between source files can and should be fully captured by the `%path::dependencies` hash during the build-system's startup load of `lib/path.pm` from your source tree, which is how the built-in views contained in our `SunStarSys::View` `Perl` package are meant to operate. The `walk_content_tree`, `archived`, and `seed_deps` utility functions importable from `SunStarSys::Util` are useful aids in constructing the `%path::dependencies` hash, with built-in support for managing a dependency cache to accelerate incremental builds at scale.

Here's our live

[`lib/path.pm`](https://vcs.sunstarsys.com/repos/svn/public/cms-sites/www.sunstarsys.com/trunk/lib/path.pm)

to mull over for ideas on how you want *your website* to work. Yes there is some reasonable complexity around how `%path::dependencies` is constructed in that file, but instead of just viewing this as optimization work, instead look at it as providing the basic ingredients necessary for construcing major aspects of the *link topology* in an automated, dynamically generated fashion.

Where do entries in `%path::dependencies` originate? If they are not born from an invocation of `walk_content_tree`, (which basically dives into your markdown source files' headers and content), then they are just hard-coded into `lib/path.pm` at load-time.

### Cyclic Dependency Graphs Are the Norm

Here's a link to a two-dimensional directed graph representation of a recent snapshot of the English language page dependencies on **our site** (using GraphViz's `dot`):

[English Language Dependencies](../images/deps.svg.gz.en)

Quite complex, even for a small website like this one! Many intersections when taking `$$n=2$$` (avoidable in dimension `$$n=3$$`). Of particular note is the core set of dense, cyclic dependencies in the non-archived files in our site's `/essays/` directory, towards the center-right of the graph, which is what a good blogging site's content topology should look like.

Of course, our [CMS](/CMS/) has never had trouble dealing with cyclic dependencies.

### Isn't this just about Hyperlinks?

In fact, the *link topology* of your website is an entirely separate matter from the source tree's *content topology*.  A search engine will naturally ferret out the *link topology*, but has no insight into the *content topology*.

Here's a current graph of the English *link topology* for **our site** (using GraphViz's `twopi`):

[English Language Links](../images/links.svg.gz.en)

The *link topology* graph is qualitatively and quantitatively **very different** from the (dramatically simpler) *content topology* graph depicted above.

### How SSI Technology Can Help

#### Traditional Server-Side Includes (SSI)

- **great** for pruning your website's *content topology* down to manageable size without sacrificiing page delivery latency
- **great** for decreasing boilerplate churn in large commit messages for better peer review and oversight of your built changesets
- **lousy** for recontexualizing entire webpages into a different location in your document root's heirarchy

#### Template APIs

##### ssi tag

- paths rooted at `content` source directory
- skips the header portion of the source file to be `ssi` included
- rewrites relative urls to absolute urls in the target path's included content

##### ssi filter

- recursively evaluates `ssi` tags in the value to be filtered
- useful for avoiding using a large value (3+) of `quick_deps` in a `@{path::patterns}` entry's argument hashref, which can impact performance

#### Why not SymLinks?

- barebones filesystem abstraction that is hard to securely support in a `VirtualHost` context
- same downsides with traditional `ssi` on full webpages
- our CMS system does not support them

#### Build Tools for Permalinks: Document Curation, Category Generation, and Archived Pages

##### Curation

The CMS build system has integrated support for what we call *Document Curation*, which is the process of recontextualizing and reorganizing your content based on how you set the `Categories` and `Archive` headers in your Markdown source files. These features are disabled by default, but can be activated by setting a `category_root` (for Category support) or an `archive_root` (for Archiving support) in the associated hashref argument to the desired `@{path::patterns}` entry.

##### Categories

- new content is constructed using Template `ssi` tags pointing back to the permalink location, while removing the `Archive` header from the constructed source page
- categories are strictly additive (i.e., removing a category from a source page's headers will not remove it from that category on the live site),
- generated on demand
- deleting all categories in a single commit is a great way to sync them with the exact specifications in all source pages' headers, without destroying the preserved category content on the live site

##### Archived Pages

On our site, we aggresssively archive stale essays to keep build times for new essays low, while not destroying permalinks to archived documents. The *content topology* relative to the `/archives/` directory (for our site) is reasonably self-contained as-per the following rules:

- content constructed using Template `ssi` tags pointing back to the permalink location, while removing the `Categories` and `Archive` headers from the constructed source page
- content in `/(essays|clients)/` are always permalinks, even after archiving
- archiving effectively removes the permalink location from the *content topology*, while not removing the permalink itself from the website

##### Teasers

HTML comments embedded in the Markdown prose form boundaries of the teaser content. We use &lt;!-- #teaser --&gt; for this purpose.

Processing teasers is done with the `teaser` Template filter. It is useful to combine this with the `ssi` filter for indexing a Category file with more than one category page within it.

## Conclusions

There are interesting data structures and relations to yet be uncovered when dealing with a website's *content topology* from a build performance perspective, which is a much newer area of interest than the research literature delving into the data structures and associated isssues surrounding *link topology*<sup>1,2</sup>.

Conventional incremental builds for pure software development projects are still a hot topic. The research covered in <sup>3,4</sup> was published in October 2022, about a month before this essay is expected to be complete.

## Footnotes

1. [Identification of clusters in the Web graph based on link topology](https://ieeexplore.ieee.org/abstract/document/1214919) Seventh International Database Engineering and Applications Symposium, 2003. Proceedings.

2. [Inferring Web Communities from Link Topology](https://dl.acm.org/doi/pdf/10.1145/276627.276652) Proceedings of the ninth ACM conference on Hypertext and hypermedia: links, objects, time and space &mdash; structure in hypermedia systems: links, objects, time and space &mdash; structure in hypermedia systems. 1998.

3. [On the benefits and limits of incremental build software configurations: an exploratory study](https://dl.acm.org/doi/abs/10.1145/3510003.3510190) ICSE '22: Proceedings of the 44th International Conference on Software Engineering, May 2022

4. [Towards incremental build of software configurations](https://dl.acm.org/doi/10.1145/3510455.3512792) ICSE-NIER '22: Proceedings of the ACM/IEEE 44th International Conference on Software Engineering: New Ideas and Emerging Results, May 2022


*$Date$*
